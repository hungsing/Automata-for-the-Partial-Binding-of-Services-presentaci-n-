%% Requires compilation with XeLaTeX or LuaLaTeX
\documentclass[10pt,xcolor={table,dvipsnames},t]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amssymb}
\usepackage{amsfonts,amsmath,amsthm} % Math packages
\usepackage{mathabx}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{xypic}
\usepackage{graphicx}
\usepackage[lofdepth,lotdepth]{subfig}
\usepackage{float}
% \usepackage[shortlabels]{enumitem}
\usetikzlibrary{babel,automata,positioning,arrows}
\newcommand{\Tau}{\mathrm{T}}
\newtheorem{ejemplo}{Ejemplo}
\title{Auómatas para la vinculación parcial de servicios}
% \subtitle{Your subtitle (if there's one)}
\author{Ezequiel Davidovich Caballero}
\institute{Departamento de Computación, Facultad de Ciencias Exactas y Naturales}
\date{11 de Noviembre 2020}


\begin{document}


\begin{frame}
\vspace{-2cm}
\begin{center}
\begin{tabular}{l}
\includegraphics[width=2cm]{logofcen.pdf}
\end{tabular}    
\end{center}

  \titlepage
  
  {

{Director: Carlos G. Lopez Pombo}

\vspace{.2cm}

{Codirector: Ignacio Vissani}

\vspace{.2cm}

Buenos Aires, 2020
}
\end{frame}

% Uncomment these lines for an automatically generated outline.
%\begin{frame}{Outline}
%  \tableofcontents
%\end{frame}

\section{Introduction}

\begin{frame}{Service-oriented Computing}

Service-oriented computing (SOC) es el paradigma de cómputo que utiliza servicios como elementos fundamentales para el desarrollo de aplicaciones. Para construir este modelo de servicios, SOC se basa en un modo de reorganizar el aplicaciones de software e infraestructura en un conjunto de servicios que interactúan entre sí.

En Service-oriented computing los sistemas de software tienen tres características distintivas:
\begin{itemize}
  \item \textbf{Reconfiguración dinámica:} la estructura del sistema varía en tiempo de ejecución a medida que este va requiriendo servicios externos para completar una tarea necesaria para cumplir su objetivo

  \item \textbf{Heterogeneidad intrínseca:} los servicios que se utilizan durante la ejecución se toman de repositorios y su naturaleza es desconocida fuera del contrato sobre el cual se establece el Service Level Agreement
  
  \item \textbf{Altamente no determinísticos:} los repositorios cambian a lo largo del tiempo como consecuencia de servicios que se registran y desregistran constantemente. Por lo tanto no hay garantía de que un mismo servicio satisfaga dos requerimientos idénticos 

\end{itemize}

\end{frame}

\section{ARN}

\begin{frame}{Asynchronous Relational Nets}

Un enfoque para representar este tipo de sistemas son las Asynchronous Relational Nets (ARNs) definidas por Fiadeiro y López. un álgebra de componentes e interfaces, independiente de otros modelos de análisis, que caracteriza la estructura del diseño SOC.\\
Consisten de redes de procesos que interactúan a través de canales de comunicación en forma asincrónica.\\
Una interfaz de servicios ofrece propiedades a potenciales clientes y requiere propiedades de servicios externos que requieran ser descubiertos y vinculados, en tiempo de ejecución, a la orquestación del servicio.

\end{frame}


\begin{frame}{Asynchronous Relational Nets características}

\begin{itemize}
    \item Modelo basado en orquestación: requieren un servicio que coordine el funcionamiento del sistema compuesto por,

    \item Un hipergrafo $\langle X,E \rangle$ donde $X$ es el conjunto finito de nodos (denominados puertos) y $E$ el conjunto de hiper ejes que se dividen por su función en hiper ejes de cómputo y de comunicación
    
    \item Tres funciones de etiquetado que asignan:
        \begin{itemize}
            \item[o] Un puerto $M_x$ a cada nodo de $X$
            \item[o] Un proceso a cada hiper eje de cómputo 
            \item[o] Una conexión a cada hiper eje de comunicación
        \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{ARNs:Semántica Operacional}
    Un aporte al modelo es el agregado de una semántica operacional que permitiera modelar la capacidad de composición parcial. Para esto los hiper ejes (tanto de comunicación como de cómputo) pasan a ser modelados con autómatas de Muller.
    \begin{itemize}
        \item[\textbf{Pro:}] Esta modificación trae a las ARNs el concepto de reconfiguración y ejecución dinámica, y permite la posibilidad de hacer chequeo de compliance (que la visión global sea igual que la local) entre un conjunto de participantes.
        
        \item[\textbf{Contra:}]Los autómatas de Muller sirven para modelar cómputo pero no son compatibles con la noción de comunicación.
    \end{itemize}
\end{frame}

\begin{frame}{Communicating Relational Networks}
   La modificación de las ARNs seguía sin satisfacer del todo los ideales de SOC. Para resolver esto surgen las Communicating Relational Networks (CRNs) como variante de las ARNs con las siguientes modificaciones
    \begin{itemize}
        \item Los hiper ejes pasan a modelarse con global graphs.
        \item Los puertos ahora son communicating finite state machines (CFSMs).
        \item Cambia a un modelo basado en la idea de coreografía. Es decir la comunicación se organiza en base a interacciones entre los componentes sin necesidad de un servicio que controle.
    \end{itemize}
\end{frame}

\begin{frame}{CRNs: Características}
Esta modificación trae una serie de ventasjas:
\begin{enumerate}
    \item Chequeo de compliance más sencillo: o bien probando que la proyección del global graph es bisimilar a la de la CFSM correspondiente o bien probando que las CFSMs cumplen con la condición de General Multiparty Compatibility (GMC)
    \item El enfoque de coreografía se acerca a proveer una visión donde los distintos servicios se coordinan entre sí sin necesidad de un servicio que se ocupe específicamente de esa tarea.
\end{enumerate}
\end{frame}

\begin{frame}{Communicating Finite State Machines}
Son un tipo de autómatas de comunicación asincrónica donde los participantes intercambian mensajes a través de canales FIFO. Se definen sobre un conjunto de mensajes $\mathcal{M}$ como una estructura $\langle Q, \mathcal{C}, q_0, \mathcal{M}, \delta \rangle$. Donde $Q$ es el conjunto de estados, $\mathcal{C}$ el conjunto de canales de comunicación (uno en cada sentido por cada par de participantes), $q_0 \in Q$ el estado inicial y $\delta \subseteq Q \times \{!,?\} \times \mathcal{M} \times Q$ la relación de transición.

\begin{center}
\begin{tabular}{ccc}
   p &   r & s\\
\begin{tikzpicture}[->, thick]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [right= of q_0 ] {$q_1$};
  \node[state] (q_2) [below= of q_0 ] {$q_2$};
 \node[state] (q_3) [right= of q_2 ] {$q_3$};
 \draw[]        
        (q_0) edge[above] node{pr!a} (q_1)
        (q_0) edge[right] node{sp?b} (q_2)
        (q_1) edge[right] node{sp?b} (q_3)
        (q_2) edge[above] node{pr!a} (q_3)
        ; 
\end{tikzpicture} 
&
\begin{tikzpicture}[->, thick]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [below= of q_0 ] {$q_1$};

 \draw[]        
        
        (q_0) edge[right] node{pr?a} (q_1)
        
        ;
\end{tikzpicture} 
&
\begin{tikzpicture}[->, thick]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [below= of q_0 ] {$q_1$};

 \draw[]        
        
        (q_0) edge[right] node{sp!b} (q_1)
        
        ;
\end{tikzpicture} 
\end{tabular}
\end{center}
\end{frame}

\begin{frame}{Global Graphs y GMC}
Un Global Graph es un grafo etiquetado $\langle V, A, \Lambda \rangle$ definido sobre un conjunto de participantes $\mathcal{P}$ y un conjunto de mensajes $\mathcal{M}$. El mismo se compone de un conjunto de vértices $V$, un conjunto de ejes $A \subseteq V \times V$ y una función de etiquetado $\Lambda: A \rightarrow L$. 

Dado un conjunto de participantes $\mathcal{P}$ y sus respectivas CFSMs $M_p$ llamamos Communicating System (CS) a la tupla $S=(M_p)_{p \in \mathcal{P}}$ y un par $s=\langle \overrightarrow{q} ; \overrightarrow{\omega} \rangle$ a una configuración de $S$. General Multiparty Compatibility (GMC) es una condición sólida y completa para construir global graphs a partir de un CS. La condición de GMC garantiza que si el CS es seguro, es decir que carece de configuraciones de: 
\begin{itemize}
    \item Deadlock
    \item Recepción no especificada
    \item Mensajes huérfanos
\end{itemize}
    
\end{frame}

\begin{frame}{Problemas a Resolver}
\begin{enumerate}
    \item Si bien los métodos de vinculación y chequeo de compliance son más sencillos tienen una desventaja respecto a la versión anterior de la ARNs. \\
    \item Para poder hacer el chequeo de compliance es necesario que estén presentes todos los participantes de la comunicación. Es decir, se pierde la idea de vinculación dinámica porque sí o sí todos los servicios que van a ser requeridos tienen que ser conocidos.\\
    \item Para solucionar estos problemas buscamos un formalismo con mecanismo de composición que permita proyectarse a CFSMs y recuperar la noción de composición parcial.

\end{enumerate}
\end{frame}

\begin{frame}{Autómatas Finitos de Comunicación Asincrónica}

Los Autómatas Finitos de Comunicación Asincrónica (AFCA) son una clase de autómatas de comunicación de la forma $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$ que poseen:
\begin{itemize}
    \item Comunicación externa a través de los canales en $\mathcal{C}$
    \item Transiciones internas o de cómputo,
    \item Comunicación interna a través de buffers
    \item Un mecanismo de composición que admite composición parcial transformando la comunicación externa compartida entre participantes en comunicación interna del autómata resultante
\end{itemize} 

La interfaz de comunicación externa de un AFCA se puede proyectar en una communicating machine. Para lo cual definimos las Multichannel Communicating Finite State Machines (mCFSM). CFSMs con más de un par de canales entre cada par de participantes
\end{frame}

\begin{frame}{AFCA ejemplo}
Ejemplo de un Autómata Finito de Comunicación Asincrónica
Considere el AFCA $S= \langle \{q_0,..,q_5\},\{b_0\},\{sr_1,sr_2,rs_1\}, \Sigma_A, \delta_A, q_0, \{q_4\} \rangle$. Donde $\Sigma =\{wait, b_0 \ll m_1,b_0 \gg m_1, Out(sr_1,a),Out(sr_2,c), In(rs_1,b),In(rs_2,d) \}$
\begin{center}
\begin{tikzpicture}[->, thick]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [right= 1.5cm of q_0 ] {$q_1$};
 \node[state] (q_5) [right= 1.8cm of q_1 ] {$q_5$};
 \node[state] (q_2) [below= of q_0 ] {$q_2$};
 \node[state] (q_3) [right= 1.5cm of q_2 ] {$q_3$};
 \node[state,accepting] (q_4) [right= 1.8cm of q_3 ] {$q_4$};
 \draw[]        
        (q_0) edge[above] node{$b_0 \ll m_1$} (q_1)
        (q_0) edge[left] node{$Out(sr_1,a)$} (q_2)
        (q_1) edge[above] node{$Out(sr_2,c)$} (q_5)
        (q_2) edge[above] node{$In(rs_1,b)$} (q_3)
        (q_2) edge[bend right, below] node{$wait$} (q_4)
        (q_3) edge[above] node{$In(rs_2,d)$} (q_4)
        (q_5) edge[right] node{$b_0 \gg m_1$} (q_4)
        ;
\end{tikzpicture}
\end{center}
En el ejemplo podemos ver los tres tipos de transiciones que los AFCA pueden realizar. 
\end{frame}

\begin{frame}{Composición parcial}
Para modelar la reconfiguración dinámica en tiempo de ejecución los AFCA incorporan un mecanismo de composición que admite composición parcial:
\begin{itemize}
    \item Decimos que un conjunto de AFCA son compatibles para componer si vale $\Sigma_{p_i} \cap \Sigma_{p_j}= \emptyset$ y $B_{p_i} \cap B_{p_j} = \emptyset$ para todo $p_i, p_j \in \mathcal{P}$
    \item $Q_\mathcal{P}= \Pi_{p_i \in \mathcal{P}} Q_{p_i}$ El conjunto de estados resultantes es el producto de los conjuntos de los componentes
    \item $B_\mathcal{P} = \bigcup_{p_i \in \mathcal{P}} B_{p_i} \cup \{ \omega_c \ | \ \mbox{ existen } p_i, p_j \in \mathcal{P} \mbox{ tales que } c \in \mathcal{C}_{p_i} \cap \mathcal{C}_{p_j} \}$ El conjunto de buffers internos es la unión de los de los componenetes más uno nuevo por cada canal de comunicación externa compartido entre cada par de AFCA
    \item $\Sigma_\mathcal{P} = \bigcup_{p_i \in \mathcal{P}} \Sigma_{p_i}$ con $\Sigma_{\mathcal{P}\mathit{Ex}} = \bigcup_{p_i \in \mathcal{P}} \Sigma_{p_i\mathit{Ex}} \setminus \Sigma_{p_i \mapsto p_j}$ y $\Sigma_{\mathcal{P}\mathit{Buff}} = \bigcup_{p_i \in \mathcal{P}} \Sigma_{p_i\mathit{Buff}} \cup \Sigma_{p_i \mapsto p_j}$,
    \item $\delta_\mathcal{P}$ 
    
\end{itemize}
    
\end{frame}

\begin{frame}{Composición parcial ejemplo}
Tomemos estos tres AFCA como ejemplo, podemos ver que cumplen la condición necesaria de compatibilidad.

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[->, thick, scale=0.8, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [right= 1.5cm of q_0 ] {$q_1$};
 \node[state] (q_2) [below= of q_0 ] {$q_2$};
 \node[state] (q_3) [right= 1.5cm of q_2 ] {$q_3$};
 \node[state, accepting] (q_4) [below= of q_3 ] {$q_4$};
	
 \draw[]        
        (q_0) edge[above] node{out(PR,a)} (q_1)
        (q_0) edge[left] node{in(SP,b)} (q_2)
        (q_1) edge[right] node{in(SP,b)} (q_3)
        (q_2) edge[above] node{out(PR,a)} (q_3)
        (q_3) edge[right] node{$int_p$} (q_4)
        ; 
\end{tikzpicture} 
\ 
\begin{tikzpicture}[->, thick,scale=0.8, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [below= of q_0 ] {$q_1$};
 \node[state, accepting] (q_2) [below= of q_1 ] {$q_2$};
 \draw[]        
        
        (q_0) edge[right] node{$int_r$} (q_1)
        (q_1) edge[right] node{in(pr,a)} (q_2)
        ;
\end{tikzpicture} 
\ 
\begin{tikzpicture}[->, thick,scale=0.6, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state, accepting] (q_1) [below= of q_0 ] {$q_1$};

 \draw[]        
        
        (q_0) edge[right] node{out(sp,b)} (q_1)
        
        ;
\end{tikzpicture} 
\end{center}
% \caption{Autómatas finitos de comunicación asincrónica $A_P$, $A_R$, $A_S$.}
\label{a_i}
\end{figure}
\end{frame}

\begin{frame}{Composición parcial ejemplo}
\begin{figure}[H]
\begin{tikzpicture}[->, thick,scale=0.5, every node/.style={transform shape}]
 \node[state,initial] (q_0)  {$q_{00}$}; 
 \node[state] (q_1) [below right=  and 3 of q_0] {$q_{01}$};
 \node[state] (q_2) [below = 1.5 of q_1 ] {$q_{11}$};
 \node[state] (q_3) [below = 2.5 of q_2 ] {$q_{12}$};
 \node[state] (q_4) [below= of q_0] {$q_{10}$};
  \node[state] (q_5) [below left = of q_3 ] {$q_{32}$};
  \node[state] (q_6) [below = 1.5cm of q_4] {$q_{30}$};
  \node[state] (q_7) [below = 1.5 of q_6 ] {$q_{31}$};
  \node[state] (q_8) [below left = and 3 of q_0 ] {$q_{20}$};
  \node[state] (q_9) [below =2 of q_8 ] {$q_{21}$};
  \node[state] (q_10) [below left= of q_7] {$q_{41}$};
 \node[state,accepting] (q_11) [below= 3cm of q_7] {$q_{42}$};
 \draw[]        
        (q_0) edge[above] node{$int_r$} (q_1)
        (q_0) edge[above] node{$in(SP,b)$} (q_8)
        (q_0) edge[right] node{$PR \ll a$} (q_4)
        (q_1) edge[right] node{$PR \ll a$} (q_2)
 		(q_2) edge[right] node{$PR \gg a$} (q_3)
		(q_2) edge[right] node{$in(SP,b)$} (q_7)
        (q_3) edge[right] node{$in(SP,b)$} (q_5) 
        (q_4) edge[right] node{$in(SP,b)$} (q_6)
        (q_6) edge[left] node{$int_r$} (q_7)
        (q_7) edge[right] node{$PR \gg a$} (q_5)
        (q_7) edge[left] node{$int_p$} (q_10)
        (q_10) edge[left] node{$PR \gg a$} (q_11)
        (q_8) edge[left] node{$int_r$} (q_9)
        (q_8) edge[left] node{$PR \ll a$} (q_6)
        (q_9) edge[left] node{$PR \ll a$} (q_7)
        (q_5) edge[right] node{$int_p$} (q_11)
        ;
\end{tikzpicture}
 \
\begin{tikzpicture}[->, thick,scale=0.6, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [below= of q_0 ] {$q_1$};

 \draw[]        
        
        (q_0) edge[right] node{out(sp,b)} (q_1)
    
        ;
\end{tikzpicture}

% \caption{Composición parcial de los AFCAs de la Fig.~\ref{a_i}.}
% \label{A-parcial}
\end{figure}
\end{frame}


\begin{frame}{MultiChannel CFSM y GMC}
\begin{itemize}
    \item Multichannel Communicating Finite State Machines (mCFSM). Son una extensión CFSMs con múltiples canales (al menos dos, uno en cada sentido) entre cada par de participantes.
    
    \item Interfaz de comunicación de AFCA: mediante un procedimiento extraemos el comportamiento comunicacional en la forma de una mCFSM
    
    \item Sistema emulado: Dado un multichannel CS $(M_p)_{p \in \mathcal{P}}$, agrandamos el conjunto $ \mathcal{P}$ agregando un participante adicional por cada canal en el sistema original $\mathcal{P}'=\mathcal{P} \cup \bigcup_{p \in \mathcal{P}} \{p^{pq_n} \ | \ pq_n \in \mathcal{C}_p \} \cup \bigcup_{p \in \mathcal{P}} \{p^{qp_n} \ | \ qp_n \in \mathcal{C}_p \}$. De este modo obtenemos un conjunto de CFSMs
    
    \item GMC: Como el sistema emulado preserva errores comunicacionales, podemos utilizar el criterio de GMC para el chequeo de compliance entre componentes
\end{itemize}

\end{frame}

\begin{frame}{Equivalencia comunicacional}
Queremos garantizar que dado un conjunto de AFCA compatibles, y sus respectivas mCFSMs la composición total preserva la semántica comunicacional.  

\begin{figure}[H]
$$
\xymatrix{   
	\{\mathcal{A}_i\}_{i \in I} \ar[rrr]_{\Pi} \ar[d]_{||} & & & \{C_i\}_{i \in I}  \ar[d]_{semantica}  \\
	  {A} \ar[r]_{\Pi'} \ar[d]_{\Pi} & \mathcal{L}' & = & {\mathcal{L}}  \\
	  \emptyset
}
$$
% \caption{La composición de componentes asincrónicas preserva la semántica asincrónica de su interfaz de comunicación.}
\end{figure}
    
\end{frame}

\begin{frame}{Equivalencia comunicacional problema}

El primer problema es que no siempre ocurre. Como en este caso.

\begin{center}
\begin{tabular}{c}
\begin{tikzpicture}[->, thick,scale=0.6, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [below = of q_0 ] {$q_1$};
 \node[state] (q_2) [right = of q_1 ] {$q_2$};
 \node[state] (q_3) [below = of q_1 ] {$q_3$};
 \node[state] (q_4) [below = of q_2 ] {$q_4$};
 \draw[]        
        (q_0) edge[left] node{int1} (q_1)
        (q_0) edge[right] node{int2} (q_2)
        (q_1) edge[left] node{in(sp,a)} (q_3)
        (q_2) edge[right] node{in(sp,b)} (q_4)
        ; 
\end{tikzpicture}
\qquad
\begin{tikzpicture}[->, thick,scale=0.6, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [below = of q_0 ] {$q_1$};
  \node[state] (q_2) [right = of q_1] {$q_2$};
 \draw[]        
        (q_0) edge[left] node{out(sp,a)} (q_1)
        (q_0) edge[right] node{out(sp,b)} (q_2)
        ; 
\end{tikzpicture}
\vspace{0.5in}\\
\begin{tikzpicture}[->, thick,scale=0.6, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$[q_0]$}; 
  \node[state] (q_1) [below = of q_0 ] {$[q_1]$};
 \node[state] (q_2) [right = of q_1 ] {$[q_2]$};
 \draw[]        
        (q_0) edge[left] node{sp?a} (q_1)
        (q_0) edge[right] node{sp?b} (q_2)
        ; 
\end{tikzpicture}
\qquad
\begin{tikzpicture}[->, thick,scale=0.6, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$[q_0]$}; 
 \node[state] (q_1) [below = of q_0 ] {$[q_1]$};
  \node[state] (q_2) [right = of q_1 ] {$[q_2]$};
 \draw[]        
        (q_0) edge[left] node{sp!a} (q_1)
        (q_0) edge[right] node{sp!b} (q_2)
        ; 
\end{tikzpicture}
\end{tabular}
\end{center}
\end{frame}

\begin{frame}{Weak determinacy}
Primero buscamos un criterio que garantice la preservación de la comunicación. Y con este criterio vemos un método de "extraer" la comunicación interna de un AFCA. Para un AFCA $A= \langle Q, \mathcal{C}, B, \Sigma, \delta, q_0, F \rangle$

\begin{enumerate}
    \item Weak Determinacy: Sea $\Sigma' \subseteq \Sigma$ un conjunto de etiquetas a silenciar. Se dice que $A$ es \emph{weak determinate sobre $\Sigma'$} si para todo $q, q', q'' \in Q$ y para todo $s, s' \in \Sigma^*$ tal que $\widehat{s}_{\Sigma'} = \widehat{s'}_{\Sigma'}$, $q \xrightarrow{s} q'$ y $q \xrightarrow{s'} q''$, $q' \sim_{\Sigma'} q''$.\\

    \item Decimos que si $A$ es weak determinate, entonces dados dos estados $q, q' \in Q$ tales que $q \xrightarrow{\sigma} q'$ con $\sigma \in \Sigma_{\mathit{Int}}^*$,  $q \sim_{\Sigma_\mathit{Int}} q'$.
    
    \item Si $A$ weak determinate, definimos equivalencia de estados por comunicación interna como $q \Rightarrow q'$ si y solo si existe $\sigma \in \Sigma_\mathit{Int}$ tal que $q \xrightarrow{\sigma} q'$. Luego, $[q]_m$, \emph{la clase de equivalencia por comunicación interna} de $q$, se define como $[q]_m = \{q'\ |\ q \Rightarrow^\bullet q'\}$. 
    
    \item Decimos que dos clases de equivalencia están relacionadas $[q]_m \xrightarrow{\sigma} [q']_m$ sii $\exists q_i \in [q]_m, q'_i \in [q']_m$ tales que $q_i \xrightarrow{\sigma} q'_i \in \delta_{\text{Buff}}$
\end{enumerate}
\end{frame}

\begin{frame}{Proyección de comunicación interna}
Tomando el AFCA $A$, weak determinate sin transiciones de comunicación externa, definimos la Proyección de Comunicación Interna $\Tau(A)$ como la proyección de la semántica de comunicación de $\mathcal{A}$. Llamamos $\widehat{\mathcal{A}}$ al sistema de transición etiquetado resultante y decimos que $\Tau (\langle Q, B, \mathcal{C}, \Sigma, q_0, \delta, F \rangle)= \langle \widehat{Q}, B, \widehat{q_0}, \widehat{\Delta} \rangle$ tal que:
\begin{itemize}
    \item $ \widehat{Q} = \{ \langle [q]_m, \overrightarrow{\Omega} \rangle | q \in Q \land \overrightarrow{\Omega} = (\Omega_b)_{b \in B}$ con $\Omega_b \in \mathcal{M}^* \}$ Cada estado del sistema de transición resultante es una configuración de $\mathcal{A}$ para una clase de equivalencia por comunicación interna,
    \item $B$ es el conjunto de buffers de $\mathcal{A}$ que se utilizan en las aristas del LTS para denotar de comunicación interna
    \item $\widehat{q_0}= \langle q_0, \Omega \rangle$ es el estado inicial de  donde $q_0$ es el estado inicial de $\mathcal{A}$ y $\Omega = \langle [], \ldots, [] \rangle$ es el conjunto de buffers en su estado inicial sin mensajes, y
    \item $\widehat{\Delta}= \{\langle \langle q_i, \Omega \rangle, \widehat{\sigma},\langle q_j, \Omega' \rangle \rangle | q_i, q_j \in Q, \widehat{\sigma} \in \{B \times \{\gg, \ll\} \times \mathcal{M}\} \land \exists \sigma \in \Sigma$ tal que  $[q_i]_m \xrightarrow{\sigma} [q_j]_m \}$. Definimos $\widehat{\Delta}$ como la relación de transición de $\widehat{\mathcal{A}}$. Un estado de $\widehat{q_j}$ es alcanzable desde otro $\widehat{q_i}$ si la clase de equivalencia $[q_j]_m$ es alcanzable desde $[q_i]_\mathcal{M}$.
\end{itemize}
\end{frame}

\begin{frame}{Proyección de comunicación interna ejemplo}
Dado el AFCA compuesto $\mathcal{A}= \langle \{q_{000},\ldots,q_{121}\}, \emptyset, \{PR,SP\}, \Sigma_{\mathcal{A}}, \delta_{\mathcal{A}}, \{q_{000}\}, \{q_{421}\} \rangle$
\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[->, thick, scale=0.6, every node/.style={transform shape}]
 \node[state,initial] (q_0)   {$q_{000}$}; 
 \node[state] (q_1) [right= 1.5cm of q_0 ] {$q_{100}$};
 \node[state] (q_2) [right = 1.5 of q_1 ] {$q_{110}$};
 \node[state] (q_12) [above right= 2 of q_2 ] {$q_{111}$};
  \node[state] (q_3) [below right= 2 of q_2 ] {$q_{120}$};
  \node[state] (q_4) [right = 3.1 of q_2 ] {$q_{121}$};
  \node[state] (q_5) [below= 4 of q_0] {$q_{001}$};
  \node[state] (q_6) [right = 1.5cm of q_5] {$q_{201}$};
   \node[state] (q_7) [above right = 2 of q_6 ] {$q_{301}$};
  \node[state] (q_11) [below = 3.5 of q_7] {$q_{211}$};
  \node[state] (q_8) [right = 3.5 of q_6] {$q_{311}$};
  \node[state] (q_9) [above right = 2 of q_8 ] {$q_{321}$};
  \node[state] (q_13) [below right= 2 of q_8 ] {$q_{411}$};
 \node[state,accepting] (q_10) [right= 3.5cm of q_8 ] {$q_{421}$};
 \draw[]        
        (q_0) edge[above] node{$PR \ll a$} (q_1)
        (q_1) edge[above] node{$int_r$} (q_2)
		(q_2) edge[left] node{$PR \gg a$} (q_3)
		(q_2) edge[left] node{$SP \ll b$} (q_12)
		(q_12) edge[left] node{$PR \gg a$} (q_4)
        (q_3) edge[left] node{$SP \ll b$} (q_4) 
        (q_4) edge[right] node{$SP \gg b$} (q_9)
        (q_0) edge[left] node{$SP \ll b$} (q_5)
        (q_5) edge[below] node{$SP \gg b$} (q_6)
        (q_6) edge[left] node{$PR \ll a$} (q_7)
        (q_6) edge[below] node{$int_r$} (q_11)
        (q_11) edge[right] node{$PR \ll a$} (q_8)
        (q_7) edge[right] node{$int_r$} (q_8)
        (q_8) edge[right] node{$int_p$} (q_13)
        (q_8) edge[right] node{$PR \gg a$} (q_9)
        (q_13) edge[right] node{$PR \gg a$} (q_10)
        (q_9) edge[above] node{$int_p$} (q_10)
        ;
\end{tikzpicture}
\end{center}
% \caption{Composición de los AFCAs de la Fig.~\ref{a_i}.}
\label{A}
\end{figure}

\end{frame}

\begin{frame}{Proyeción de comunicación interna}
\begin{figure}[H]

\begin{center}
\begin{tikzpicture}[->, thick, scale=0.6, every node/.style={transform shape}]
    \node[state,initial] (q_0) {$[q_{000}],\epsilon, \epsilon$}; 
     \node[state] (q_1) [right= 3.5cm of q_0 ] {$[q_{100}], a, \epsilon$};
     \node[state] (q_2) [right = 3.5cm of q_1 ] {$[q_{120}],\epsilon,\epsilon$};
     \node[state] (q_8) [below= of q_1 ] {$[q_{111}], a, b$};
     \node[state] (q_3) [below= of q_2 ] {$[q_{121}],\epsilon, b$};
     \node[state] (q_4) [below=  of q_0] {$[q_{001}],\epsilon, b$};
     \node[state] (q_5) [below = of q_4] {$[q_{201}],\epsilon, \epsilon$};
     \node[state] (q_6) [right = 3.5cm of q_5 ] {$[q_{301}], a, \epsilon$};
     \node[state,accepting] (q_7) [below = of q_3 ] {$[q_{321}],\epsilon, \epsilon$};
\draw[]        
     (q_0) edge[above] node{$\langle q_{000}, PR \ll a, q_{100} \rangle$} (q_1)
	 (q_1) edge[above] node{$\langle q_{110}, PR \gg a, q_{120} \rangle$} (q_2)
	 (q_1) edge[left] node{$\langle q_{110}, SP \ll b, q_{111} \rangle$} (q_8)
	 (q_8) edge[above] node{$\langle q_{111}, PR \gg a, q_{121} \rangle$} (q_3)
     (q_2) edge[left] node{$\langle q_{120}, SP \ll b, q_{121} \rangle$} (q_3) 
     (q_3) edge[left] node{$\langle q_{121}, SP \gg b, q_{321} \rangle$} (q_7)
     (q_0) edge[left] node{$\langle q_{000}, SP \ll b, q_{001} \rangle$} (q_4)
     (q_4) edge[left] node{$\langle q_{001}, SP \gg b, q_{201} \rangle$} (q_5)
     (q_5) edge[below] node{$\langle q_{201}, SP \gg b, q_{301} \rangle$} (q_6)
     (q_6) edge[below] node{$\langle q_{311}, PR \ll a, q_{321} \rangle$} (q_7)
      ;
\end{tikzpicture}
\end{center}
\caption{Proyección de comunicación interna del AFCA  $\mathcal{A}$.}
% \label{ex:pci}
\end{figure}
\end{frame}

\begin{frame}{Equivalencia Comunicacional}
Para ver que la composición preserva la semántica comunicacional de un conjunto de AFCA  y sus respectivas mCFSMs queremos probar que $\widehat{\mathcal{A}}$ y $M$ son bisimilares. Para lo cual necesitamos que: 
\begin{enumerate}
    \item $\{\mathcal{A}\}_{1 \leq i \leq n}$ sea un conjunto de weak determinate AFCA sin transiciones de comunicación interna
    \item su composición $\mathcal{A}$, también es weak determinate
    \item $\widehat{\mathcal{A}}$ el sistema de transición etiquetado (LTS) que resulta de la proyección $\Tau(\mathcal{A})$
    \item $\{M_i\}_{1 \leq i \leq n}$ de mCFSM correspondientes a cada uno de los AFCAs
    \item $M = \langle P, \mathcal{C}, {p_0}, [\delta] \rangle$ el LTS que representa la semántica del CS
\end{enumerate}
\end{frame}

\begin{frame}{Equivalencia Comunicacional}
Dadas las condiciones establecidas necesitamos probar:
\begin{enumerate}
    \item \textbf{Equivalencia de estados discretos:} Para todo $\langle [\overrightarrow{q}]_m, \overrightarrow{\Omega} \rangle \in \widehat{Q}$, existe $\langle \overrightarrow{p}, \overrightarrow{\Omega_{\mathcal{C}}} \rangle \in P$ tal que $q_i \in \overrightarrow{q} \iff q_i \in \overrightarrow{p}$ y viceversa.
    \item \textbf{Equivalencia entre buffers y canales:} Dados $\langle [\overrightarrow{q}]_m, \overrightarrow{\Omega} \rangle \in \widehat{Q}$ y $\langle \overrightarrow{p}, \overrightarrow{\Omega_{\mathcal{C}}} \rangle \in P$. Queremos ver que el conjunto de buffers $B$ de $\mathcal{A}$ es el conjunto de canales internalizados de $\mathcal{C}$ de $M$. Es decir que para todo canal $\omega$ vale que $\omega \in \mathcal{C}$ si y solo si $\omega \in B$
\end{enumerate}
    
\end{frame}

\end{document}
